Dhall/YAML configurable concurrent job executor with streaming assertion checks
for linux platforms. `dhrun` starts a list of processes, monitors the standard
streams for patterns that should be expected or avoided, kills the processes
when criteria are met and exits accordingly. The goals are similar to
[venom](https://github.com/ovh/venom). Compared to that tool, `dhrun` has
only one execution capability(exec) and its assertions are poor(infix strings
only). It supports concurrency and monitors streams online, however. it was
written to create a configuration layer above runs of single-node integration
tests for client-server applications.

### Use

Resolve imports, normalize, and run a dhrun configuration on the fly with:
```{.bash}
dhrun run path/to/config.dhall 
```

Or use YAML:
```{.bash}
dhrun run path/to/config.yaml
```

See the [examples](./examples/) directory for example `.yml` and `.dh`
configurations. The [resources](./resources) directory contains the Dhall
types for the configuration layer. File [quickstart.yml](./quickstart.yml)
serves as a quickstart example.

A workflow to evaluate the config via a dhall codebase at configuration time
might involve `dhall` and `dhall-to-yaml`:

```{.bash}
dhall resolve <<< "let codebase = /path/package.dhall in codebase.foo bar baz" |\
dhall normalize |\
dhall-to-yaml |\
dhrun run "-" 
```

### CLI Interface 

```{.hidden pipe="bash"}
echo "dhrun --help"
cd root
cabal build > /dev/null
```

```{.txt pipe="sh"}
root/dist/build/dhrun/dhrun --help
```

```{.bash}
dhrun run --help
```

```{.txt pipe="sh"}
root/dist/build/dhrun/dhrun run --help
```

### Installation

There is a small vendored Nix codebase in `/nix` that packages `dhrun`. It pins
nixpkgs 18.09, so this should take a minute. Note that I have not tried
building this code using stack.

```
nix-env -f . -iA dhrun
```

The hackage dependencies for `dhrun` and its tests are:

```{.unwrap pipe="runhaskell | pandoc -t json"}
{-# language OverloadedStrings #-}
{-# language NoImplicitPrelude #-}
import Protolude
import Distribution.PackageDescription.Parsec
import Distribution.PackageDescription
import Distribution.PackageDescription.Configuration
import Distribution.Verbosity
import Distribution.Types.Dependency
import Distribution.Types.PackageName
import Data.Text as T (pack)
main = do
  pdesc <- readGenericPackageDescription
             normal
             "root/dhrun.cabal"
  let depnames =
       map (unPackageName . depPkgName) $
       allBuildDepends $
       flattenPackageDescription pdesc
  for_ depnames $ \x -> putText $ "`" <> toS x <> "`"
```

### Hacking

- `nix-shell` provides a dev environment with cabal-build, ghcid, hlint,
  brittany, and other tools. There is a small vendored codebase in /nix that
  provides this.  

- you need to procure
  [`dhall-to-cabal`](https://github.com/dhall-lang/dhall-to-cabal) separately
  because I didn't see fit to add that package as of the shell environment.
  It's necessary if you want to edit the cabal file, which is done through
  [`./cabal.dh`](./cabal.dh).

- edit `.README.md` instead of `README.md` and run `./shake readme`. `./shake`
  also has other useful dev workflows.

- `direnv allow` for [lorri](https://github.com/target/lorri) integration.

The structure of the code is the following.

- `/resources` Dhall types and helper functions.

- `/app` the main cli tool.

- `/examples`s example Dhall and YAML configuration files for dhrun. These
  also serve as golden tests.

- `/src` dhrun types and logic.

- `/tests` golden, unit, quickcheck tests.
