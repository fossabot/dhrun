`dhrun`
=======

This is a Dhall/YAML configurable concurrent job executor meant to be used for
pass/fail CI tests. It starts a list of processes, monitors the standard
streams for patterns that should be expected or avoided, kills the processes
when those criteria are met and exits accordingly. This is in the spirit of
[venom](https://github.com/ovh/venom). Compared to that tool, dhrun has only
one execution capability and its assertion specifications are poor. It supports
concurrency, however.

### Use

Resolve imports, normalize, and run a dhrun configuration on the fly with:

```{.bash}
dhrun run path/to/config.dhall 
```

Or use YAML:
```{.bash}
dhrun run path/to/config.yaml
```

See the [examples](./examples/) directory for example `.yml` and `.dh` configurations.
The [resources](./resources) directory contains the Dhall types for the configuration
layer. File [quickstart.yml](./quickstart.yml) serves as a quickstart example.


Useful command-line options are the following:

- `dhrun print` prints the result of a dhall config to stdout
- The `"-"` file input argument forces the binary to use the standard input
  (assuming the YAML format).
- The `-e` option allows to edit the configuration (in YAML) on the fly before
  execution

A workflow to evaluate the config via a dhall codebase at configuration time
might involve `dhall` and `dhall-to-yaml`:

```{.bash}
dhall resolve <<< "let codebase = /path/package.dhall in codebase.foo bar baz" |\
dhall normalize |\
dhall-to-yaml |\
dhrun run "-" 
```

### CLI Interface 

```{.hidden pipe="bash"}
echo "dhrun --help"
cd root
cabal build > /dev/null
```

```{.txt pipe="sh"}
root/dist/build/dhrun/dhrun --help
```

```{.bash}
dhrun run --help
```

```{.txt pipe="sh"}
root/dist/build/dhrun/dhrun run --help
```


### Installation

There is a small vendored Nix codebase in /nix.

```
nix-env -f . -iA dhrun
```

The `/nix` folder is mostly there to manage the development workflow so feel
free to try other ways. The hackage dependencies for `dhrun` and its tests are:

```{.unwrap pipe="runhaskell | pandoc -t json"}
{-# language OverloadedStrings #-}
{-# language NoImplicitPrelude #-}
import Protolude
import Distribution.PackageDescription.Parsec
import Distribution.PackageDescription
import Distribution.PackageDescription.Configuration
import Distribution.Verbosity
import Distribution.Types.Dependency
import Distribution.Types.PackageName
import Data.Text as T (pack)
main = do
  pdesc <- readGenericPackageDescription
             normal
             "root/dhrun.cabal"
  let depnames =
       map (unPackageName . depPkgName) $
       allBuildDepends $
       flattenPackageDescription pdesc
  for_ depnames $ \x -> putText $ "`" <> toS x <> "`"
```


### Hacking

- `nix-shell` provides a dev environment with cabal-build, ghcid, hlint,
  brittany, and others. There is a small vendored codebase in /nix that
  provides this via nixpkgs pinning.  

- you need to procure
  [`dhall-to-cabal`](https://github.com/dhall-lang/dhall-to-cabal) separately
  because I didn't see fit to add that package as of the shell environment.
  It's necessary if you want to edit the cabal file, which is done through
  [`./cabal.dh`](./cabal.dh).

- edit `.README.md` instead of `README.md` and run `./shake readme`. `./shake`
  also has other useful dev workflows.

- `direnv allow` for [lorri](https://github.com/target/lorri) integration.

The structure of the code is the following.

- `/resources` Dhall types and helper functions.

- `/app` the main cli tool.

- `/examples`s example Dhall and YAML configuration files for dhrun. These
  also serve as golden tests.

- `/src` dhrun types and logic.

- `/tests` golden, unit, quickcheck tests.
